<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Usefull_Functions</title>
</head>
<body>
    <style>
        #proba{
            width: 50px;
            height: 50px;
            background-color: red;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
        }
    </style>
    <div id="proba"></div>
    <div id='RED' style='position: absolute; width: 50px; height: 50px;
      left: 200px; top: 400px; background-color: red; border-radius: 50%'></div>
<div id='GREEN' style='position: absolute; width: 20px; height: 20px;
    background-color: green; border-radius: 50%'></div>

<form name=FPos>
Расстояние (радиус): <input type=text name=Radius value='100'><br />
Угол (в градусах): <input type=text name=Angle value='30'><br />
<input type=button value='позиционировать' onclick='pos()'>
</form>
    <script src="Js/usefulFunction.js"></script>

    <script src="zepto.js"></script>
<script src="zepto-touch.js"></script> // introduction module
<script>
    $(function() {
		$(document).tap(function() {
			console.log("Click on the screen.");
		});
		$(document).doubleTap(function() {
			console.log("Double-click on the screen.");
		});
		$(document).longTap(function() {
			console.log("Long press more than 750ms");
		});
		$(document).swipe(function() {
			console.log("Scratched");
		});
		$(document).swipeLeft(function() {
			console.log("Left scratched");
		});
		$(document).swipeUp(function() {
			console.log("On scratched");
		});
		//......
	});
    
;(function($){
  var touch = {},
    touchTimeout, tapTimeout, swipeTimeout, longTapTimeout,
    longTapDelay = 750,
    gesture,
    down, up, move,
    eventMap,
    initialized = false

  // sliding direction
  function swipeDirection(x1, x2, y1, y2) {
    // First judge which relative displacement is larger in the horizontal or vertical direction, if the horizontal direction is larger, it is horizontal sliding, otherwise it is vertical sliding
    return Math.abs(x1 - x2) >=
    // After judging the direction, compare the displacement of the two gesture points, and judge by the displacement difference to slide up, down, left, and right
      Math.abs(y1 - y2) ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down')
  }

  // Press
  function longTap() {
    // Clear the longTabTimeout timer
    longTapTimeout = null
    // If touch.last exists, trigger the longTap event, and then clear the touch object for next use
    if (touch.last) {
      touch.el.trigger('longTap')
      touch = {}
    }
  }

  // Cancel long press
  function cancelLongTap() {
    // Clear the longTabTimeout timer
    if (longTapTimeout) clearTimeout(longTapTimeout)
    longTapTimeout = null
  }

  // cancel all
  function cancelAll() {
    // Clear all timers, and then clear the touch object for next use
    if (touchTimeout) clearTimeout(touchTimeout)
    if (tapTimeout) clearTimeout(tapTimeout)
    if (swipeTimeout) clearTimeout(swipeTimeout)
    if (longTapTimeout) clearTimeout(longTapTimeout)
    touchTimeout = tapTimeout = swipeTimeout = longTapTimeout = null
    touch = {}
  }

  // Is it the main contact
  function isPrimaryTouch(event){
    // Judge by checking that the event type is a click event and the main contact. Only handle finger events
    return (event.pointerType == 'touch' ||
      event.pointerType == event.MSPOINTER_TYPE_TOUCH)
      && event.isPrimary
  }

  // Is it a click event type
  function isPointerEventType(e, type){
    // It is politically correct to spray Microsoft on the front end anyway, for the browser hack specially written by Microsoft
    return (e.type == 'pointer'+type ||
      e.type.toLowerCase() == 'mspointer'+type)
  }

  // The unregistered event is actually to check whether the initialization has been performed
  function unregisterTouchEvents(){
    if (!initialized) return
    $(document).off(eventMap.down, down)
      .off(eventMap.up, up)
      .off(eventMap.move, move)
      .off(eventMap.cancel, cancelAll)
    $(window).off('scroll', cancelAll)
    cancelAll()
    initialized = false
  }

  // Initializing the module is actually a way of self-execution 
  function setup(__eventMap){
    var now, delta, deltaX = 0, deltaY = 0, firstTouch, _isPointerType

    unregisterTouchEvents()

    // According to different browsers, given different event types, the use is unified within the framework
    eventMap = (__eventMap && ('down' in __eventMap)) ? __eventMap :
      ('ontouchstart' in document ?
      { 'down': 'touchstart', 'up': 'touchend',
        'move': 'touchmove', 'cancel': 'touchcancel' } :
      'onpointerdown' in document ?
      { 'down': 'pointerdown', 'up': 'pointerup',
        'move': 'pointermove', 'cancel': 'pointercancel' } :
       'onmspointerdown' in document ?
      { 'down': 'MSPointerDown', 'up': 'MSPointerUp',
        'move': 'MSPointerMove', 'cancel': 'MSPointerCancel' } : false)

    if (!eventMap) return

    // Everyday hacking Microsoft, this is to deal with IE
    if ('MSGesture' in window) {
      // Create a gesture object
      gesture = new MSGesture()
      // bind object
      gesture.target = document.body

      $(document)
        .bind('MSGestureEnd', function(e){
        // Bind the event, analyze the gesture direction under IE, and then trigger the corresponding event
        // This code is similar to swipeDirection
          var swipeDirectionFromVelocity =
            e.velocityX > 1 ? 'Right' : e.velocityX < -1 ? 'Left' : e.velocityY > 1 ? 'Down' : e.velocityY < -1 ? 'Up' : null
          if (swipeDirectionFromVelocity) {
            touch.el.trigger('swipe')
            touch.el.trigger('swipe'+ swipeDirectionFromVelocity)
          }
        })
    }

    down = function(e){
      // As long as it is not a sliding event, or it is not a sliding down, then return directly, do not perform the following steps
      if((_isPointerType = isPointerEventType(e, 'down')) &&
        !isPrimaryTouch(e)) return
      // If it is a sliding event, record the information of the first finger
      firstTouch = _isPointerType ? e : e.touches[0]
      // When single finger operation, reset the end point information
      if (e.touches && e.touches.length === 1 && touch.x2) {
        touch.x2 = undefined
        touch.y2 = undefined
      }
      // Record contact information
      now = Date.now()
      delta = now - (touch.last || now)
      touch.el = $('tagName' in firstTouch.target ?
        firstTouch.target : firstTouch.target.parentNode)
      touchTimeout && clearTimeout(touchTimeout)
      touch.x1 = firstTouch.pageX
      touch.y1 = firstTouch.pageY
      // Check for double-click event
      if (delta > 0 && delta <= 250) touch.isDoubleTap = true
      // Check if the long press event
      touch.last = now
      longTapTimeout = setTimeout(longTap, longTapDelay)
      // Black IE, handle IE separately
      if (gesture && _isPointerType) gesture.addPointer(e.pointerId)
    }

    move = function(e){
    // As long as it is not a sliding event, or it is not a move event, return directly, do not perform the following steps
      if((_isPointerType = isPointerEventType(e, 'move')) &&
        !isPrimaryTouch(e)) return
      firstTouch = _isPointerType ? e : e.touches[0]
      // It moved, it must not be a long press event, cancel the long press event
      cancelLongTap()
      //Record the information of the moving destination
      touch.x2 = firstTouch.pageX
      touch.y2 = firstTouch.pageY
      // Calculate the displacement between the start and end points of finger movement
      deltaX += Math.abs(touch.x1 - touch.x2)
      deltaY += Math.abs(touch.y1 - touch.y2)
    }

    up = function(e){
    // As long as it is not a sliding event, or it is not an up event, return directly, do not perform the following steps
      if((_isPointerType = isPointerEventType(e, 'up')) &&
        !isPrimaryTouch(e)) return
        // The finger was released, it must not be a long press, cancel the long press
      cancelLongTap()

      // If the movement between the fingers exceeds 30, then it is a swipe sliding event
      if ((touch.x2 && Math.abs(touch.x1 - touch.x2) > 30) ||
          (touch.y2 && Math.abs(touch.y1 - touch.y2) > 30))
        // trigger the corresponding sliding event
        swipeTimeout = setTimeout(function() {
          if (touch.el){
            touch.el.trigger('swipe')
            touch.el.trigger('swipe' + (swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2)))
          }
          touch = {}
        }, 0)

      else if ('last' in touch)
        if (deltaX < 30 && deltaY < 30) {
          // If last exists, it is not a swipe event.
          tapTimeout = setTimeout(function() {
            var event = $.Event('tap')
            event.cancelTouch = cancelAll
            if (touch.el) touch.el.trigger(event)

            if (touch.isDoubleTap) {
              if (touch.el) touch.el.trigger('doubleTap')
              touch = {}
            }

            else {
              touchTimeout = setTimeout(function(){
                touchTimeout = null
                if (touch.el) touch.el.trigger('singleTap')
                touch = {}
              }, 250)
            }
          }, 0)
        } else {
          touch = {}
        }
        deltaX = deltaY = 0
    }

    $(document).on(eventMap.up, up)
      .on(eventMap.down, down)
      .on(eventMap.move, move)
    $(document).on(eventMap.cancel, cancelAll)
    $(window).on('scroll', cancelAll)

    initialized = true
  }
  // Bind callback to the corresponding event
  ;['swipe', 'swipeLeft', 'swipeRight', 'swipeUp', 'swipeDown',
    'doubleTap', 'tap', 'singleTap', 'longTap'].forEach(function(eventName){
    $.fn[eventName] = function(callback){ return this.on(eventName, callback) }
  })

  $.touch = { setup: setup }

  $(document).ready(setup)
})(Zepto)


</script>
</body>
</html>